Code completion task:

Complete the Verilog RTL for 'neuron_mac_serial' using the conceptual description in '/workdir/docs/Specification.md'.
The RTL must be synthesizable and work with Icarus Verilog (no SystemVerilog-only features).

High-level behavior (see the spec for the exact math)
This block behaves as a fixed-point neuron with masking and a selectable activation function. For each operation it should:
- Treat inputs, weights, bias and output as signed two's-complement fixed-point values with fractional bits X_FRAC, W_FRAC, B_FRAC and OUT_FRAC.
- Consider the right scaling for the fractional operations internally.
- For each index i, if the mask bit for that index is one, add the corresponding product x[i]*w[i] into the accumulator; if the mask bit is zero, that product simply does not contribute.
- After all selected products have been added, apply the activation in the accumulator domain according to 'act_sel':
  - '2'b00': identity (leave the value unchanged),
  - '2'b01': ReLU (clamp negative values to zero),
  - '2'b10': leaky ReLU with a negative slope of one quarter,
  - '2'b11': hard-tanh-style clamp to the integer range that represents real values between âˆ’1.0 and +1.0 in the internal fractional scale.
- Convert the activated accumulator value the internal bit width to OUT_FRAC using the same deterministic right-shift rounding rule described in the spec, then clip the final result to the signed OUT_W-bit range and drive it on 'out_data'.

Input packing and ordering
The inputs are presented as packed vectors and must be unpacked consistently:
- 'x_flat' contains NUM_INPUTS signed X_W-bit samples in little-endian order by index, so element zero is in the least significant bits and element i is taken from the slice 'i*X_W +: X_W'.
- 'w_flat' is packed in the same way for the weights.
- 'mask_flat' holds one bit per element; a value of one means "include this product in the sum", and a value of zero means "ignore this product".
The computation is serial: element zero is processed first, then one, and so on up to NUM_INPUTS minus one, with exactly one element handled on each clock while the block is busy.

Handshake, timing and reset
The control interface uses a simple valid-ready style protocol. The signal 'in_ready' must be high exactly when the block is idle, which in this design means it is the logical negation of 'busy'. A new operation begins on a rising clock edge when both 'in_valid' and 'in_ready' are high at the same time. On that edge the design should capture 'x_flat', 'w_flat', 'bias', 'mask_flat' and 'act_sel', reset its internal element index, initialize the accumulator with the aligned bias, assert 'busy', and then start consuming one element per cycle. While 'busy' remains high, the block walks through all indices in order and updates the accumulator according to the mask. On the cycle that processes the last index, it finishes the accumulation, applies the selected activation, performs the final fixed-point conversion and saturation, drives the result on 'out_data', raises 'out_valid' for exactly one clock cycle, and then clears 'busy' so that 'in_ready' becomes high again.

The reset input 'rst_n' is active-low and asynchronous. While 'rst_n' is low, the design must clear all internal registers, force 'busy' and 'out_valid' to zero, and set 'out_data' to zero. After 'rst_n' returns high, the block is idle and ready to accept a new operation, with 'in_ready' high until the first transaction is started.

Partial RTL to complete:

'timescale 1ns/1ps
module neuron_mac_serial #(
	parameter integer NUM_INPUTS = 8,

	parameter integer X_W       = 8,   // input sample width (signed)
	parameter integer W_W       = 8,   // weight width (signed)
	parameter integer B_W       = 32,  // bias width (signed)
	parameter integer OUT_W     = 16,  // output width (signed)

	// Fixed-point fractional bits for each quantity.
	parameter integer X_FRAC    = 4,
	parameter integer W_FRAC    = 4,
	parameter integer B_FRAC    = 8,
	parameter integer OUT_FRAC  = 8,

	// Extra headroom in accumulator
	parameter integer GUARD_BITS = 2
)(
	input  wire                         clk,
	input  wire                         rst_n,

	input  wire                         in_valid,
	output wire                         in_ready,
	input  wire signed [B_W-1:0]        bias,
	input  wire        [NUM_INPUTS*X_W-1:0] x_flat,
	input  wire        [NUM_INPUTS*W_W-1:0] w_flat,

	// Runtime-selectable activation function
	input  wire        [1:0]            act_sel,

	// Sparsity mask
	input  wire        [NUM_INPUTS-1:0] mask_flat,

	// Output handshake
	output reg                          out_valid,
	output reg  signed [OUT_W-1:0]      out_data,

	output reg                          busy
);

// Insert your implementation here

endmodule
