Code completion task:

Complete the Verilog-2001 RTL for 'neuron_mac_serial' using the conceptual math in '/workdir/docs/Specification.md'.
The finished RTL must be synthesizable and compatible with Icarus Verilog (avoid SystemVerilog-only features).

What to implement
- Compute a fixed-point neuron: y = bias + Î£(x[i]*w[i]) with optional ReLU and final saturation.
- All values are signed two's-complement fixed-point integers with fractional bits:
  x: X_FRAC, w: W_FRAC, bias: B_FRAC, output: OUT_FRAC.

Fixed-point rules (conceptual, match the spec)
- Product fractional bits: FRAC_P = X_FRAC + W_FRAC (accumulator is interpreted in this scale).
- Bias must be aligned into FRAC_P before accumulation.
- When reducing fractional bits via right shift, use deterministic rounding:
  add 2^(sh-1) if value >= 0, subtract 2^(sh-1) if value < 0, then arithmetic shift right by sh.
- If USE_RELU != 0, clamp negative accumulated result to 0 before output quantization/saturation.
- Quantize accumulator from FRAC_P to OUT_FRAC (right/left shift as needed, using the same rounding rule on right shifts).
- Saturate the final result to the signed OUT_W-bit range.

Input packing (must match)
- 'x_flat' packs NUM_INPUTS signed X_W-bit values, little-endian by index:
    x[0] = x_flat[X_W-1:0],  x[i] = x_flat[i*X_W +: X_W]
- 'w_flat' packs weights the same way:
    w[0] = w_flat[W_W-1:0],  w[i] = w_flat[i*W_W +: W_W]
- Element 0 must be processed first, then 1, ..., NUM_INPUTS-1.

Handshake + sequencing (must match)
- 'in_ready' is high only when the module is idle, and must be combinational: in_ready = ~busy.
- A transaction starts on a rising clock edge where in_valid and in_ready are set; capture x_flat/w_flat/bias for the whole operation.
- While busy is high, process exactly one (x[i], w[i]) pair per clock cycle (serial MAC).
- After NUM_INPUTS cycles of MAC work, produce the result:
  - 'out_valid' must pulse high for exactly 1 cycle
  - 'out_data' must be valid in that same cycle
  - there is no out_ready; do not hold out_valid high.
- Active-low reset must clear state: busy=0, out_valid=0, out_data=0, and internal regs to 0.

Partial RTL provided:

module neuron_mac_serial #(
    parameter integer NUM_INPUTS = 8,
    parameter integer X_W       = 8,
    parameter integer W_W       = 8,
    parameter integer B_W       = 32,
    parameter integer OUT_W     = 16,
    parameter integer X_FRAC    = 4,
    parameter integer W_FRAC    = 4,
    parameter integer B_FRAC    = 8,
    parameter integer OUT_FRAC  = 8,
    parameter integer GUARD_BITS = 2,
    parameter integer USE_RELU  = 1
)(
    input  wire                         clk,
    input  wire                         rst_n,
    input  wire                         in_valid,
    output wire                         in_ready,
    input  wire signed [B_W-1:0]        bias,
    input  wire        [NUM_INPUTS*X_W-1:0] x_flat,
    input  wire        [NUM_INPUTS*W_W-1:0] w_flat,
    output reg                          out_valid,
    output reg  signed [OUT_W-1:0]      out_data,
    output reg                          busy
);

// Insert your implementation here

endmodule
