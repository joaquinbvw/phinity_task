Code completion task:

Complete the Verilog RTL for 'neuron_mac_serial' using the conceptual description in '/workdir/docs/Specification.md'.
The RTL must be synthesizable and work with Icarus Verilog (no SystemVerilog-only features).

High-level behavior (see the spec for the exact math)
This block behaves as a fixed-point neuron with masking and a selectable activation function. For each operation it should:
- Treat inputs, weights, bias and output as signed two's-complement fixed-point values with fractional bits X_FRAC, W_FRAC, B_FRAC and OUT_FRAC.
- Consider the right scaling for the fractional operations internally.
- For each index i, if the mask bit for that index is one, add the corresponding product x[i]*w[i] into the accumulator; if the mask bit is zero, that product simply does not contribute.
- After all selected products have been added, apply the activation in the accumulator domain according to 'act_sel':
  - '2'b00': identity (leave the value unchanged),
  - '2'b01': ReLU (clamp negative values to zero),
  - '2'b10': leaky ReLU with a negative slope of one quarter,
  - '2'b11': hard-tanh-style clamp to the integer range that represents real values between âˆ’1.0 and +1.0 in the internal fractional scale.
- Convert the activated accumulator value the internal bit width to OUT_FRAC using the same deterministic right-shift rounding rule described in the spec, then clip the final result to the signed OUT_W-bit range and drive it on 'out_data'.

Input packing and ordering
The inputs are presented as packed vectors and must be unpacked consistently:
- 'x_flat' contains NUM_INPUTS signed X_W-bit samples in little-endian order by index, so element zero is in the least significant bits and element i is taken from the slice 'i*X_W +: X_W'.
- 'w_flat' is packed in the same way for the weights.
- 'mask_flat' holds one bit per element; a value of one means "include this product in the sum", and a value of zero means "ignore this product".
The computation is serial: element zero is processed first, then one, and so on up to NUM_INPUTS minus one. If a mask bit is zero, that element is skipped immediately; if a mask bit is one, that element uses a dedicated sequential multiplier and may therefore take additional cycles before the accumulator is updated.

Handshake, timing and reset
The control interface uses a simple valid-ready style protocol.
The signal 'in_ready' must be high exactly when the block is idle and able to accept a new operation. A new operation begins on a rising clock edge when both 'in_valid' and 'in_ready' are high at the same time. On that edge the design should capture 'x_flat', 'w_flat', 'bias', 'mask_flat' and 'act_sel', reset its internal element index, initialize the accumulator with the aligned bias, assert 'busy', and then start walking through the elements in order.

While 'busy' remains high, the block walks through all indices in order and updates the accumulator according to the mask. For masked-off elements it should simply advance to the next index. For masked-on elements it must obtain the product through a sequential signed multiplier submodule that can take one or more cycles: the top-level must only launch a multiply when the multiplier is ready, and it must wait until the multiplier produces a valid product before adding it into the accumulator and advancing. Only one multiply operation may be in flight at a time.

When the final result is ready, the module must drive the result on 'out_data' and assert 'out_valid'. Unlike a one-cycle pulse interface, 'out_valid' must support backpressure using 'out_ready':
- If 'out_ready' is high, the result is accepted on that cycle.
- If 'out_ready' is low, 'out_valid' must remain asserted until 'out_ready' eventually becomes high, and 'out_data' must remain stable for the entire time 'out_valid' is high and 'out_ready' is low.
- While an output is pending acceptance ('out_valid'=1 and 'out_ready'=0), the block is still considered busy: keep 'busy'=1 and keep 'in_ready' low so that no new operation can be accepted.

The reset input 'rst_n' is active-low and asynchronous. While 'rst_n' is low, the design must clear all internal registers, force 'busy' and 'out_valid' to zero, and set 'out_data' to zero. After 'rst_n' returns high, the block is idle and ready to accept a new operation, with 'in_ready' high until the first transaction is started.

Partial RTL to complete:

`timescale 1ns/1ps
module neuron_mac_serial #(
	parameter integer NUM_INPUTS = 8,

	parameter integer X_W       = 8,   // input sample width (signed)
	parameter integer W_W       = 8,   // weight width (signed)
	parameter integer B_W       = 32,  // bias width (signed)
	parameter integer OUT_W     = 16,  // output width (signed)

	// Fixed-point fractional bits for each quantity.
	parameter integer X_FRAC    = 4,
	parameter integer W_FRAC    = 4,
	parameter integer B_FRAC    = 8,
	parameter integer OUT_FRAC  = 8,

	// Extra headroom in accumulator
	parameter integer GUARD_BITS = 2
)(
	input  wire                         clk,
	input  wire                         rst_n,

	input  wire                         in_valid,
	output wire                         in_ready,
	input  wire signed [B_W-1:0]        bias,
	input  wire        [NUM_INPUTS*X_W-1:0] x_flat,
	input  wire        [NUM_INPUTS*W_W-1:0] w_flat,

	// Runtime-selectable activation function
	input  wire        [1:0]            act_sel,

	// Sparsity mask
	input  wire        [NUM_INPUTS-1:0] mask_flat,

	// Output handshake with backpressure
	output reg                          out_valid,
	input  wire                         out_ready,
	output reg  signed [OUT_W-1:0]      out_data,

	output reg                          busy
);

// Insert your implementation here

endmodule
